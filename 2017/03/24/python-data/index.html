<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python," />








  <link rel="shortcut icon" type="image/x-icon" href="http://ok9ixm52w.bkt.clouddn.com/bitbug_favicon%20%281%29.ico?v=5.1.0" />






<meta name="description" content="Python中的高级数据结构参考url

前言
python基本的数据结构有list,dict,set等，足够平常的使用，但在实现一些比较复杂的逻辑时，我们需要设计更好的数据结构去完成任务，此时我们需要去参考是否有更好的已经存在的数据结构，这样我们可以高效利用而不用浪费功夫去重复造轮子。这些数据结构都是继承了最基本的数据结构，在这之上去构造一些新的属性和方法去丰富数据结构的功能。下面就是一些pyt">
<meta property="og:type" content="article">
<meta property="og:title" content="python--data">
<meta property="og:url" content="http://go.wangxx.win/2017/03/24/python-data/index.html">
<meta property="og:site_name" content="wang_xun_xing">
<meta property="og:description" content="Python中的高级数据结构参考url

前言
python基本的数据结构有list,dict,set等，足够平常的使用，但在实现一些比较复杂的逻辑时，我们需要设计更好的数据结构去完成任务，此时我们需要去参考是否有更好的已经存在的数据结构，这样我们可以高效利用而不用浪费功夫去重复造轮子。这些数据结构都是继承了最基本的数据结构，在这之上去构造一些新的属性和方法去丰富数据结构的功能。下面就是一些pyt">
<meta property="og:image" content="http://ok9ixm52w.bkt.clouddn.com/1488882579345_10.png">
<meta property="og:image" content="http://ok9ixm52w.bkt.clouddn.com/830203241171405010.jpg">
<meta property="og:updated_time" content="2017-03-24T04:06:01.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python--data">
<meta name="twitter:description" content="Python中的高级数据结构参考url

前言
python基本的数据结构有list,dict,set等，足够平常的使用，但在实现一些比较复杂的逻辑时，我们需要设计更好的数据结构去完成任务，此时我们需要去参考是否有更好的已经存在的数据结构，这样我们可以高效利用而不用浪费功夫去重复造轮子。这些数据结构都是继承了最基本的数据结构，在这之上去构造一些新的属性和方法去丰富数据结构的功能。下面就是一些pyt">
<meta name="twitter:image" content="http://ok9ixm52w.bkt.clouddn.com/1488882579345_10.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://go.wangxx.win/2017/03/24/python-data/"/>





  <title> python--data | wang_xun_xing </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wang_xun_xing</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just do iT!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-github">
          <a href="https://github.com/wstarxing" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github"></i> <br />
            
            menu.github
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://go.wangxx.win/2017/03/24/python-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangxunxing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ok9ixm52w.bkt.clouddn.com/17-1F2211F427.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wang_xun_xing">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                python--data
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T11:25:34+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Python中的高级数据结构"><a href="#Python中的高级数据结构" class="headerlink" title="Python中的高级数据结构"></a>Python中的高级数据结构</h1><p><a href="http://blog.jobbole.com/65218/" target="_blank" rel="external">参考url</a></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>python基本的数据结构有list,dict,set等，足够平常的使用，但在实现一些比较复杂的逻辑时，我们需要设计更好的数据结构去完成任务，此时我们需要去参考是否有更好的已经存在的数据结构，这样我们可以高效利用而不用浪费功夫去重复造轮子。<br>这些数据结构都是继承了最基本的数据结构，在这之上去构造一些新的属性和方法去丰富数据结构的功能。<br>下面就是一些python的高级数据结构例子可以供参考。</p>
</blockquote>
<hr>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><blockquote>
<p>collections模块包含了内建类型之外的一些有用的工具，例如Counter、defaultdict、OrderedDict、deque以及nametuple。其中Counter、deque以及defaultdict是最常用的类。</p>
</blockquote>
<ol>
<li><p>Counter()</p>
<blockquote>
<p>‘’’Dict subclass for counting hashable items.  Sometimes called a bag<br> or multiset.  Elements are stored as dictionary keys and their counts<br> are stored as dictionary values.<br>是dict的子类，可以计算可哈希item的数量，Elements被保存成字典的key和他们数量的values</p>
</blockquote>
<pre><code> c = Counter(&apos;abcdeabcdabcaba&apos;)  
 # count elements from a string,计算字符串的出现的数值

 c.most_common(3)                
 # three most common elements,表示出现最多的3个
[(&apos;a&apos;, 5), (&apos;b&apos;, 4), (&apos;c&apos;, 3)]
sorted(c)                       
# list all unique elements，用list去保存其唯一的值
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]
&apos;&apos;.join(sorted(c.elements()))   
# list elements with repetitions,按出现次数及其位置重新生成字符串
&apos;aaaaabbbbcccdde&apos;
sum(c.values())                 
# total of all counts,计算其总数

c[&apos;a&apos;]                          
# count of letter &apos;a&apos;,获取其中的key出现的次数

for elem in &apos;shazam&apos;:           # update counts from an iterable
     c[elem] += 1      
# by adding 1 to each element&apos;s count，对其出现的key的values都加1
c[&apos;a&apos;]                          # now there are seven &apos;a&apos;

del c[&apos;b&apos;]                      # remove all &apos;b&apos;
c[&apos;b&apos;]                          # now there are zero &apos;b&apos;
</code></pre></li>
</ol>
<pre><code>d = Counter(&apos;simsalabim&apos;)       # make another counter
c.update(d)                     
# add in the second counter，把其他字符串的相加都一起，可以就单独计算后的合并
c[&apos;a&apos;]                          # now there are nine &apos;a&apos;
9

c.clear()                       # empty the counter，清空
Counter()

Note:  If a count is set to zero or reduced to zero, it will remain
in the counter until the entry is deleted or the counter is cleared:

c = Counter(&apos;aaabbc&apos;)
c[&apos;b&apos;] -= 2                     # reduce the count of &apos;b&apos; by two
c.most_common()                 # &apos;b&apos; is still in, but its count is zero
[(&apos;a&apos;, 3), (&apos;c&apos;, 1), (&apos;b&apos;, 0)]
</code></pre><ol>
<li>Deque<blockquote>
<p>Deque是一种由队列结构扩展而来的双端队列(double-ended queue)，队列元素能够在队列两端添加或删除。因此它还被称为头尾连接列表(head-tail linked list)，尽管叫这个名字的还有另一个特殊的数据结构实现。<br>Deque支持线程安全的，经过优化的append和pop操作，在队列两端的相关操作都能够达到近乎O(1)的时间复杂度。虽然list也支持类似的操作，但是它是对定长列表的操作表现很不错，而当遇到pop(0)和insert(0,v)这样既改变了列表的长度又改变其元素位置的操作时，其复杂度就变为O(n)了。</p>
</blockquote>
</li>
</ol>
<pre><code>def append(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Add an element to the right side of the deque. 
    在队列的右边增加新值
    &quot;&quot;&quot;

    pass

def appendleft(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Add an element to the left side of the deque. 
    在队列的左边增加新值
    &quot;&quot;&quot;
    pass

def clear(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Remove all elements from the deque. 
    清除队列所有的值
    &quot;&quot;&quot;
    pass

def count(self, value): # real signature unknown; restored from __doc__
    &quot;&quot;&quot; D.count(value) -&gt; integer -- return number of occurrences of value 
    统计value在deque出现的次数
    &quot;&quot;&quot;
    return 0

def extend(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Extend the right side of the deque with elements from the iterable 
    扩展可迭代的对象进入deque右边，如把list中的数据加入到deque中
    &quot;&quot;&quot;
    pass

def extendleft(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Extend the left side of the deque with elements from the iterable
     扩展可迭代的对象进入deque左边，插入到左边，按list中的顺序插，最后一个在最左边
    &quot;&quot;&quot;
    pass

def pop(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Remove and return the rightmost element. 
    删除deque中右边最后一个，并返回
    &quot;&quot;&quot;
    pass

def popleft(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Remove and return the leftmost element. 
    删除deque中左边边最后一个，并返回
    &quot;&quot;&quot;
    pass

def remove(self, value): # real signature unknown; restored from __doc__
    &quot;&quot;&quot; D.remove(value) -- remove first occurrence of value. 
    移除第一个出现的value
    &quot;&quot;&quot;
    pass

def reverse(self): # real signature unknown; restored from __doc__
    &quot;&quot;&quot; D.reverse() -- reverse *IN PLACE* 
    反向
    &quot;&quot;&quot;
    pass

def rotate(self, *args, **kwargs): # real signature unknown
    &quot;&quot;&quot; Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left. 
    n = 1把第一个往后退一位，第一位用最后一位补充
    n = -1把第一个往前移一位变成最后一位，后面依次往前移
    像一个圆那样挪位
    &quot;&quot;&quot;
    pass
</code></pre><ol>
<li>Defaultdict<blockquote>
<p>这个类型除了在处理不存在的键的操作之外与普通的字典完全相同。当查找一个不存在的键操作发生时，它的default_factory会被调用，提供一个默认的值，并且将这对键值存储下来。其他的参数同普通的字典方法dict()一致，一个defaultdict的实例同内建dict一样拥有同样地操作。</p>
</blockquote>
</li>
</ol>
<p>defaultdict对象在当你希望使用它存放追踪数据的时候很有用</p>
<pre><code># 假定你希望追踪一个单词在字符串中的位置，那么你可以这么做:
from collections import defaultdict

s = &quot;the quick brown fox jumps over the lazy dog&quot;

words = s.split()
location = defaultdict(list)
for m, n in enumerate(words):
    location[n].append(m)

print location
# defaultdict(&lt;type &apos;list&apos;&gt;, {&apos;brown&apos;: [2], &apos;lazy&apos;: [7], &apos;over&apos;: [5], &apos;fox&apos;: [3], &apos;dog&apos;: [8], &apos;quick&apos;: [1], &apos;the&apos;: [0, 6], &apos;jumps&apos;: [4]})
# 是选择lists或sets与defaultdict搭配取决于你的目的，使用list能够保存你插入元素的顺序，而使用set则不关心元素插入顺序，它会帮助消除重复元素
from collections import defaultdict

s = &quot;the quick brown fox jumps over the lazy dog&quot;

words = s.split()
location = defaultdict(set)
for m, n in enumerate(words):
    location[n].add(m)

print location
# defaultdict(&lt;type &apos;set&apos;&gt;, {&apos;brown&apos;: set([2]), &apos;lazy&apos;: set([7]), &apos;over&apos;: set([5]), &apos;fox&apos;: set([3]), &apos;dog&apos;: set([8]), &apos;quick&apos;: set([1]), &apos;the&apos;: set([0, 6]), &apos;jumps&apos;: set([4])})

# 另一种创建multidict的方法：
s = &quot;the quick brown fox jumps over the lazy dog&quot;
d = {}
words = s.split()

for key, value in enumerate(words):
    d.setdefault(key, []).append(value)
print d
# {0: [&apos;the&apos;], 1: [&apos;quick&apos;], 2: [&apos;brown&apos;], 3: [&apos;fox&apos;], 4: [&apos;jumps&apos;], 5: [&apos;over&apos;], 6: [&apos;the&apos;], 7: [&apos;lazy&apos;], 8: [&apos;dog&apos;]}
</code></pre><ol>
<li><p>OrderedDict</p>
<blockquote>
<p>‘Dictionary that remembers insertion order’<br>字典是Python开发中很常用的一种数据结构，但dict有个缺陷（其实也不算缺陷），迭代时并不是按照元素添加的顺序进行，可能在某些场景下，不能满足我们的要求。<br>有序字典与字典是一样的功能，只不过它保持插入字典的顺序，当需要遍历时会先访问最先插入的项。<br>一个顺序字典会记住它的key第一次插入时的顺序<br>如果一新条目重写了一个已存在的条目，它第一次插入的顺序是不会改变的。<br>删除一个条目并重新插入它，那它的顺序将移动到末尾<br>所以从OrderedDict的字面意思就可以出来ordereddict是有顺序(key被插入的先后顺序)的字典，而普通的字典是无序的 。<br>判断两个有序字段是否相等(==)需要考虑元素插入的顺序是否相等</p>
</blockquote>
<pre><code>od = OrderedDict()
od[&apos;b&apos;] = &apos;bc&apos;
od[&apos;1&apos;] = 2
od[&apos;a&apos;] = &apos;a&apos;
od[&apos;A&apos;] = &apos;A&apos;
print od.keys()
# [&apos;b&apos;, &apos;1&apos;, &apos;a&apos;, &apos;A&apos;]

od1 = OrderedDict({&apos;b&apos;: &apos;bc&apos;, &apos;1&apos;: 2, &apos;a&apos;: &apos;a&apos;, &apos;A&apos;: &apos;A&apos;})
print od1.keys()
# [&apos;1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;A&apos;]

od2 = OrderedDict([(&apos;b&apos;, &apos;bc&apos;), (&apos;1&apos;, 2), (&apos;a&apos;, &apos;a&apos;), (&apos;A&apos;, &apos;A&apos;)])
print od2.keys()
# [&apos;b&apos;, &apos;1&apos;, &apos;a&apos;, &apos;A&apos;]

od3 = {&apos;b&apos;: &apos;bc&apos;, &apos;1&apos;: 2, &apos;a&apos;: &apos;a&apos;, &apos;A&apos;: &apos;A&apos;}
print od3.keys()
# [&apos;1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;A&apos;]

# 读取json串时保持原有顺序
import json  
from collections import OrderedDict  
metadata = json.loads(text, object_pairs_hook=OrderedDict);  

# 使用OrderedDict生成新按照key排序的dict
OrderedDict(sorted(d.items(), key=lambda t: t[0]))
OrderedDict([(&apos;apple&apos;, 4), (&apos;banana&apos;, 3), (&apos;orange&apos;, 2), (&apos;pear&apos;, 1)])
</code></pre></li>
<li><p>namedtuple</p>
<blockquote>
<p>namedtuple能够用来创建类似于tuple的数据类型，除了能够用索引来访问数据，能够迭代，更能够方便的通过属性名来访问数据。<br>在python中，传统的tuple类似于数组，只能通过下标来访问各个元素，我们还需要注释每个下标代表什么数据。通过使用namedtuple，每个元素有了自己的名字，类似于C语言中的struct，这样数据的意义就可以一目了然了。<br>nametuple用起来像一个class的实例，也像list，也像是dict，但需要事先声明像类一样，后面用法就相当于实例的使用，又好像是dict，还可以用下标的方式list那样去使用。<br>当然，声明namedtuple是非常简单方便的            </p>
</blockquote>
<pre><code>&quot;&quot;&quot;Returns a new subclass of tuple with named fields.
Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;]) # 声明，创建一个类
Point.__doc__                   # docstring for the new class
&apos;Point(x, y)&apos;
p = Point(11, y=22)             # instantiate with positional args or keywords ,实例化
p[0] + p[1]                     # indexable like a plain tuple,用list下标方式使用
33
x, y = p                        # unpack like a regular tuple 赋值
x, y
(11, 22)
p.x + p.y                       # fields also accessible by name 像实例属性那样使用
33
d = p._asdict()                 # convert to a dictionary  像dict那样使用，注意要使用&quot;_asdict&quot;
d[&apos;x&apos;]
11
Point(**d)                      # convert from a dictionary  从dict导入
Point(x=11, y=22)
p._replace(x=100)               # _replace() is like str.replace() but targets named fields 重新赋值，注意要使用&quot;_replace&quot;方法
Point(x=100, y=22)
&quot;&quot;&quot;
</code></pre></li>
</ol>
<hr>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><blockquote>
<p>array模块定义了一个很像list的新对象类型，不同之处在于它限定了这个类型只能装一种类型的元素。array元素的类型是在创建并使用的时候确定的。<br>如果你的程序需要优化内存的使用，并且你确定你希望在list中存储的数据都是同样类型的，那么使用array模块很合适。<br>举个例子，如果需要存储一千万个整数，如果用list，那么你至少需要160MB的存储空间，然而如果使用array，你只需要40MB。但虽然说能够节省空间，array上几乎没有什么基本操作能够比在list上更快。<br>在使用array进行计算的时候，需要特别注意那些创建list的操作。例如，使用列表推导式(list comprehension)的时候，会将array整个转换为list，使得存储空间膨胀。一个可行的替代方案是使用生成器表达式创建新的array<br>总的来说，就是一个节省空间的list，里面的类型是一致的，在列表推导式中会变为list，所以最好的方法是用generato去创建新的array</p>
</blockquote>
<pre><code># array规定的类型
Type code   C Type             Minimum size in bytes 
&apos;c&apos;         character          1 
&apos;b&apos;         signed integer     1 
&apos;B&apos;         unsigned integer   1 
&apos;u&apos;         Unicode character  2 
&apos;h&apos;         signed integer     2 
&apos;H&apos;         unsigned integer   2 
&apos;i&apos;         signed integer     2 
&apos;I&apos;         unsigned integer   2 
&apos;l&apos;         signed integer     4 
&apos;L&apos;         unsigned integer   4 
&apos;f&apos;         floating point     4 
&apos;d&apos;         floating point     8 

import array

a = array.array(&quot;i&quot;, [1,2,3,4,5])
b = array.array(a.typecode, (2*x for x in a))

# 因为使用array是为了节省空间，所以更倾向于使用in-place操作。一种更高效的方法是使用enumerate
import array

a = array.array(&quot;i&quot;, [1,2,3,4,5])
for i, x in enumerate(a):
    a[i] = 2*x

# 对于较大的array，这种in-place修改能够比用生成器创建一个新的array至少提升15%的速度。

# 那么什么时候使用array呢？是当你在考虑计算的因素之外，还需要得到一个像C语言里一样统一元素类型的数组时。
import array
from timeit import Timer

def arraytest():
    a = array.array(&quot;i&quot;, [1, 2, 3, 4, 5])
    b = array.array(a.typecode, (2 * x for x in a))

def enumeratetest():
    a = array.array(&quot;i&quot;, [1, 2, 3, 4, 5])
    for i, x in enumerate(a):
        a[i] = 2 * x

if __name__==&apos;__main__&apos;:
    m = Timer(&quot;arraytest()&quot;, &quot;from __main__ import arraytest&quot;)
    n = Timer(&quot;enumeratetest()&quot;, &quot;from __main__ import enumeratetest&quot;)

    print m.timeit() # 5.22479210582
    print n.timeit() # 4.34367196717
</code></pre><h2 id="Heapq"><a href="#Heapq" class="headerlink" title="Heapq"></a>Heapq</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p><a href="http://www.cnblogs.com/JVxie/p/4859889.html" target="_blank" rel="external">堆的基本概念及其操作</a></p>
<blockquote>
<p>堆是一种特殊的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构指的是二叉树。<br>堆的特点是根节点的值最大（或者最小），而且根节点的两个孩子也能与孩子节点组成子树，亦然称之为堆。<br>堆分为两种，大根堆和小根堆是一颗每一个节点的键值都不小于（大于）其孩子节点的键值的树。<br>无论是大根堆还是小根堆（前提是二叉堆）都可以看成是一颗完全二叉树。下面以图的形式直观感受一下:<br><img src="http://ok9ixm52w.bkt.clouddn.com/1488882579345_10.png" alt=""><br>heapq模块使用一个用堆实现的优先级队列。堆是一种简单的有序列表，并且置入了堆的相关规则。<br>堆是一种树形的数据结构，树上的子节点与父节点之间存在顺序关系。二叉堆(binary heap)能够用一个经过组织的列表或数组结构来标识，在这种结构中，元素N的子节点的序号为2<em>N+1和2</em>N+2(下标始于0)。简单来说，这个模块中的所有函数都假设序列是有序的，所以序列中的第一个元素(seq[0])是最小的，序列的其他部分构成一个二叉树，并且seq[i]节点的子节点分别为seq[2<em>i+1]以及seq[2</em>i+2]。当对序列进行修改时，相关函数总是确保子节点大于等于父节点<br>操作时间在于O(1)-O(logn)<br>堆作为数据结构在内存和二级缓存中充当了重要的角色,优先队列</p>
</blockquote>
<pre><code>Usage:

heappush(heap, item) # pushes a new item on the heap， push item到堆中
item = heappop(heap) # pops the smallest item from the heap，pop最小的出堆
item = heap[0]       # smallest item on the heap without popping it，取堆中最小的值
heapify(x)           # transforms list into a heap, in-place, in linear time，线性化x为堆
item = heapreplace(heap, item) # pops and returns smallest item, and adds
                               # new item; the heap size is unchanged，把heap堆中最小的出堆返回，并插入item
nlargest(num, list)            #取list中最大的num个

nsmallest(num, list)           #取list中最小的num个


import heapq

heap = []  ##type的是list

for value in [20, 10, 30, 50, 40]:   
    heapq.heappush(heap, value)  # 处理入堆，这样形成的与heapify(x)一样

while heap:
    print heapq.heappop(heap)

# heapq模块有两个函数nlargest()和nsmallest()，顾名思义，让我们来看看它们的用法。

import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]

# 两个函数也能够通过一个键参数使用更为复杂的数据结构
import heapq

portfolio = [
{&apos;name&apos;: &apos;IBM&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 91.1},
{&apos;name&apos;: &apos;AAPL&apos;, &apos;shares&apos;: 50, &apos;price&apos;: 543.22},
{&apos;name&apos;: &apos;FB&apos;, &apos;shares&apos;: 200, &apos;price&apos;: 21.09},
{&apos;name&apos;: &apos;HPQ&apos;, &apos;shares&apos;: 35, &apos;price&apos;: 31.75},
{&apos;name&apos;: &apos;YHOO&apos;, &apos;shares&apos;: 45, &apos;price&apos;: 16.35},
{&apos;name&apos;: &apos;ACME&apos;, &apos;shares&apos;: 75, &apos;price&apos;: 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s[&apos;price&apos;])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s[&apos;price&apos;])

print cheap

# [{&apos;price&apos;: 16.35, &apos;name&apos;: &apos;YHOO&apos;, &apos;shares&apos;: 45},
# {&apos;price&apos;: 21.09, &apos;name&apos;: &apos;FB&apos;, &apos;shares&apos;: 200}, {&apos;price&apos;: 31.75, &apos;name&apos;: &apos;HPQ&apos;, &apos;shares&apos;: 35}]

print expensive

# [{&apos;price&apos;: 543.22, &apos;name&apos;: &apos;AAPL&apos;, &apos;shares&apos;: 50}, {&apos;price&apos;: 115.65, &apos;name&apos;: &apos;ACME&apos;, 
# &apos;shares&apos;: 75}, {&apos;price&apos;: 91.1, &apos;name&apos;: &apos;IBM&apos;, &apos;shares&apos;: 100}]

# 来看看如何实现一个根据给定优先级进行排序，并且每次pop操作都返回优先级最高的元素的队列例子。

import heapq

class Item:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return &apos;Item({!r})&apos;.format(self.name)

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]

q = PriorityQueue()
q.push(Item(&apos;foo&apos;), 1)
q.push(Item(&apos;bar&apos;), 5)
q.push(Item(&apos;spam&apos;), 4)
q.push(Item(&apos;grok&apos;), 1)

print q.pop() # Item(&apos;bar&apos;)
print q.pop() # Item(&apos;spam&apos;)
print q.pop() # Item(&apos;foo&apos;)
print q.pop() # Item(&apos;grok&apos;)
</code></pre><h2 id="Bisect"><a href="#Bisect" class="headerlink" title="Bisect"></a>Bisect</h2><blockquote>
<p>bisect模块能够提供保持list元素序列的支持。<br>它使用了二分法完成大部分的工作。<br>它在向一个list插入元素的同时维持list是有序的。<br>在某些情况下，这比重复的对一个list进行排序更为高效，并且对于一个较大的list来说，对每步操作维持其有序也比对其排序要高效。</p>
</blockquote>
<pre><code>insort_right(a, x)   # 在a中插入x，a是sorted，如果存在x就插入x在右边
insort_left(a, x)    # 在a中插入x，a是sorted，如果存在x就插入x在左边
bisect_right(a, x)   # 在a中查找插入x的位置并返回，右边位置，不插入
bisect_left(a, x)    # 在a中查找插入x的位置并返回，左边位置，不插入
bisect(a, x)         # 在a中查插入x的位置，不插入

import bisect

a = [(0, 100), (150, 220), (500, 1000)]

bisect.insort_right(a, (250,400))

print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]

# 我们可以使用bisect()函数来寻找插入点：
import bisect

a = [(0, 100), (150, 220), (500, 1000)]

bisect.insort_right(a, (250,400))
bisect.insort_right(a, (399, 450))
print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]

print bisect.bisect(a, (550, 1200)) # 5

# bisect(sequence, item) =&gt; index 返回元素应该的插入点，但序列并不被修改。

import bisect

a = [(0, 100), (150, 220), (500, 1000)]

bisect.insort_right(a, (250,400))  
bisect.insort_right(a, (399, 450))
print a # [(0, 100), (150, 220), (250, 400), (500, 1000)]

print bisect.bisect(a, (550, 1200)) # 5
bisect.insort_right(a, (550, 1200))
print a # [(0, 100), (150, 220), (250, 400), (399, 450), (500, 1000), (550, 1200)]
</code></pre><h2 id="Weakref"><a href="#Weakref" class="headerlink" title="Weakref"></a>Weakref</h2><blockquote>
<p>weakref模块能够帮助我们创建Python引用，却不会阻止对象的销毁操作，<br>对象的非永久引用</p>
</blockquote>
<p>在开始之前，我们需要明白什么是strong reference。<br>strong reference是一个对对象的引用次数、生命周期以及销毁时机产生影响的指针。<br>strong reference如你所见，就是当你将一个对象赋值给一个变量的时候产生的：</p>
<pre><code> a = [1,2,3]
 b = a

# 在这种情况下，这个列表有两个strong reference，分别是a和b。在这两个引用都被释放之前，这个list不会被销毁

class Foo(object):
    def __init__(self):
        self.obj = None
        print &apos;created&apos;

    def __del__(self):
        print &apos;destroyed&apos;

    def show(self):
        print self.obj

    def store(self, obj):
        self.obj = obj

a = Foo() # created
b = a
del a
del b # destroyed

# Weak reference则是对对象的引用计数器不会产生影响。当一个对象存在weak reference时，并不会影响对象的撤销。这就说，如果一个对象仅剩下weak reference，那么它将会被销毁。

# 你可以使用weakref.ref函数来创建对象的weak reference。这个函数调用需要将一个strong
reference作为第一个参数传给函数，并且返回一个weak reference。

 import weakref
 a = Foo()
created
 b = weakref.ref(a)
 b

# 一个临时的strong reference可以从weak reference中创建，即是下例中的b()：
 a == b() 
True
 b().show()
None

# 请注意当我们删除strong reference的时候，对象将立即被销毁。

 del a
destroyed

# 如果试图在对象被摧毁之后通过weak reference使用对象，则会返回None：
 b() is None
True

# 若是使用weakref.proxy，就能提供相对于weakref.ref更透明的可选操作。同样是使用一个strong reference作为第一个参数并且返回一个weak reference，proxy更像是一个strong reference，但当对象不存在时会抛出异常。
 a = Foo()
created
 b = weakref.proxy(a)
 b.store(&apos;fish&apos;)
 b.show()
fish
 del a
destroyed
 b.show()
Traceback (most recent call last):
  File &quot;&quot;, line 1, in ?
ReferenceError: weakly-referenced object no longer exists


# 完整的例子：

# 引用计数器是由Python的垃圾回收器使用的，当一个对象的应用计数器变为0，则其将会被垃圾回收器回收。

# 最好将weak reference用于开销较大的对象，或避免循环引用(虽然垃圾回收器经常干这种事情)。
import weakref
import gc

class MyObject(object):
    def my_method(self):
        print &apos;my_method was called!&apos;

obj = MyObject()
r = weakref.ref(obj)

gc.collect()
assert r() is obj #r() allows you to access the object referenced: it&apos;s there.

obj = 1 #Let&apos;s change what obj references to
gc.collect()
assert r() is None #There is no object left: it was gc&apos;ed.

# 提示：只有library模块中定义的class instances、functions、methods、sets、frozen sets、files、generators、type objects和certain object types(例如sockets、arrays和regular expression patterns)支持weakref。内建函数以及大部分内建类型如lists、dictionaries、strings和numbers则不支持。
</code></pre><h2 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h2><blockquote>
<p>通过shallow或deep copy语法提供复制对象的函数操作。<br>shallow和deep copying的不同之处在于对于混合型对象的操作(混合对象是包含了其他类型对象的对象，例如list或其他类实例)。<br>对于shallow copy而言，它创建一个新的混合对象，并且将原对象中其他对象的引用插入新对象。<br>对于deep copy而言，它创建一个新的对象，并且递归地复制源对象中的其他对象并插入新的对象中。<br>普通的赋值操作知识简单的将心变量指向源对象。</p>
</blockquote>
<pre><code>import copy

a = [1,2,3]
b = [4,5]

c = [a,b]

# Normal Assignment
d = c

print id(c) == id(d)          # True - d is the same object as c
print id(c[0]) == id(d[0])    # True - d[0] is the same object as c[0]

# Shallow Copy
d = copy.copy(c)

print id(c) == id(d)          # False - d is now a new object
print id(c[0]) == id(d[0])    # True - d[0] is the same object as c[0]

# Deep Copy
d = copy.deepcopy(c)

print id(c) == id(d)          # False - d is now a new object
print id(c[0]) == id(d[0])    # False - d[0] is now a new object

# shallow copy (copy())操作创建一个新的容器，其包含的引用指向原对象中的对象。

# deep copy (deepcopy())创建的对象包含的引用指向复制出来的新对象。
</code></pre><p><img src="http://ok9ixm52w.bkt.clouddn.com/830203241171405010.jpg" alt=""></p>
<pre><code># 复杂的例子：

# 假定我有两个类，名为Manager和Graph，每个Graph包含了一个指向其manager的引用，而每个Manager有一个指向其管理的Graph的集合，现在我们有两个任务需要完成：

# 1) 复制一个graph实例，使用deepcopy，但其manager指向为原graph的manager。

# 2) 复制一个manager，完全创建新manager，但拷贝原有的所有graph。

import weakref, copy

class Graph(object):
    def __init__(self, manager=None):
        self.manager = None if manager is None else weakref.ref(manager)
    def __deepcopy__(self, memodict):
        manager = self.manager()
        return Graph(memodict.get(id(manager), manager))

class Manager(object):
    def __init__(self, graphs=[]):
        self.graphs = graphs
        for g in self.graphs:
            g.manager = weakref.ref(self)

a = Manager([Graph(), Graph()])
b = copy.deepcopy(a)

if [g.manager() is b for g in b.graphs]:
    print True # True

if copy.deepcopy(a.graphs[0]).manager() is a:
    print True # True
</code></pre><h2 id="Pprint"><a href="#Pprint" class="headerlink" title="Pprint"></a>Pprint</h2><blockquote>
<p>Pprint模块能够提供比较优雅的数据结构打印方式，如果你需要打印一个结构较为复杂，层次较深的字典或是JSON对象时，使用Pprint能够提供较好的打印结果。<br>假定你需要打印一个矩阵，当使用普通的print时，你只能打印出普通的列表，不过如果使用pprint，你就能打出漂亮的矩阵结构</p>
</blockquote>
<pre><code>import pprint

matrix = [ [1,2,3], [4,5,6], [7,8,9] ]
a = pprint.PrettyPrinter(width=20)
a.pprint(matrix)

# [[1, 2, 3],
#  [4, 5, 6],
#  [7, 8, 9]]
</code></pre><h2 id="基本的数据结构example"><a href="#基本的数据结构example" class="headerlink" title="基本的数据结构example"></a>基本的数据结构example</h2><ol>
<li><p>单链链表</p>
<pre><code>class Node:
def __init__(self):
    self.data = None
    self.nextNode = None

def set_and_return_Next(self):
    self.nextNode = Node()
    return self.nextNode

def getNext(self):
    return self.nextNode

def getData(self):
    return self.data

def setData(self, d):
    self.data = d

class LinkedList:
    def buildList(self, array):
        self.head = Node()
        self.head.setData(array[0])
        self.temp = self.head
        for i in array[1:]:
            self.temp = self.temp.set_and_return_Next()
            self.temp.setData(i)
            self.tail = self.temp
        return self.head
    def printList(self):
        tempNode = self.head
        while(tempNode!=self.tail):
            print(tempNode.getData())
            tempNode = tempNode.getNext()
        print(self.tail.getData())
myArray = [3, 5, 4, 6, 2, 6, 7, 8, 9, 10, 21]

myList = LinkedList()
myList.buildList(myArray)
myList.printList()
</code></pre></li>
<li><p>用Python实现的普林姆算法 </p>
<blockquote>
<p>普林姆算法(Prims Algorithm)是图论中，在加权连通图中搜索最小生成树的算法。</p>
</blockquote>
<pre><code>from collections import defaultdict
from heapq import heapify, heappop, heappush

def prim( nodes, edges ):
    conn = defaultdict( list )
    for n1,n2,c in edges:
        conn[ n1 ].append( (c, n1, n2) )
        conn[ n2 ].append( (c, n2, n1) )

    mst = []
    used = set( nodes[ 0 ] )
    usable_edges = conn[ nodes[0] ][:]
    heapify( usable_edges )

    while usable_edges:
        cost, n1, n2 = heappop( usable_edges )
        if n2 not in used:
            used.add( n2 )
            mst.append( ( n1, n2, cost ) )

            for e in conn[ n2 ]:
                if e[ 2 ] not in used:
                    heappush( usable_edges, e )
    return mst

#test
nodes = list(&quot;ABCDEFG&quot;)
edges = [ (&quot;A&quot;, &quot;B&quot;, 7), (&quot;A&quot;, &quot;D&quot;, 5),
          (&quot;B&quot;, &quot;C&quot;, 8), (&quot;B&quot;, &quot;D&quot;, 9), (&quot;B&quot;, &quot;E&quot;, 7),
      (&quot;C&quot;, &quot;E&quot;, 5),
      (&quot;D&quot;, &quot;E&quot;, 15), (&quot;D&quot;, &quot;F&quot;, 6),
      (&quot;E&quot;, &quot;F&quot;, 8), (&quot;E&quot;, &quot;G&quot;, 9),
      (&quot;F&quot;, &quot;G&quot;, 11)]

print &quot;prim:&quot;, prim( nodes, edges )
</code></pre></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/20/fastDFS/" rel="next" title="fastDFS">
                <i class="fa fa-chevron-left"></i> fastDFS
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/28/flask-signal/" rel="prev" title="flask-signal">
                flask-signal <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ok9ixm52w.bkt.clouddn.com/17-1F2211F427.jpg"
               alt="wangxunxing" />
          <p class="site-author-name" itemprop="name">wangxunxing</p>
           
              <p class="site-description motion-element" itemprop="description">???</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python中的高级数据结构"><span class="nav-number">1.</span> <span class="nav-text">Python中的高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections"><span class="nav-number">1.2.</span> <span class="nav-text">collections</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array"><span class="nav-number">1.3.</span> <span class="nav-text">Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heapq"><span class="nav-number">1.4.</span> <span class="nav-text">Heapq</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆的定义"><span class="nav-number">1.4.1.</span> <span class="nav-text">堆的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bisect"><span class="nav-number">1.5.</span> <span class="nav-text">Bisect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Weakref"><span class="nav-number">1.6.</span> <span class="nav-text">Weakref</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copy"><span class="nav-number">1.7.</span> <span class="nav-text">Copy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pprint"><span class="nav-number">1.8.</span> <span class="nav-text">Pprint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的数据结构example"><span class="nav-number">1.9.</span> <span class="nav-text">基本的数据结构example</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangxunxing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
